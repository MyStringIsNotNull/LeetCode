package easy;
/**
 * @author 学徒
 *
 */
/*
 * ps:DFA即为确定有限状态机
 * question:
 * 有一个长达几百万位的二进制数，求出除以3的余数是多少。
 * 
 * 此题的解题思路
 * 1.一般容易想到的就是将二进制数转化为十进制数，然后将其结果与3之间进行求模运算，其算法时间复杂度高不说
 * 由于数据类型的限制，其可能并没有办法存储下相应的二进制转化为十进制对应的数字，为此，此种算法的思想摒除
 * 
 * 2.考虑一个问题,一个二进制数(其对应的十进制数暂时记为i)，在其后添加上一个1或者一个0，其数的大小为2*i+1或者2*i
 * 而若一个二进制数(其对应的二进制数暂时记为i)，其进行模3运算之后的余数为k，商为x，则其对应二进制在其后添加一个0或者1
 * 其对应的结果(在这里，是理解结果为i*2或者i*2+1同时也等于(x*3+k)*2+1?（表示可能加一也可能不加）)进行模3运算之后
 * 得到的结果为[(x*3+k)*2+1?]%3==[x*6+2*k+1?]%3==(2*k+1?)%3即为上一个值进行模3运算之后的余数其对应的二进制在其后添加
 * 一个1或者0进行模3运算之后的结果
 * 考虑到这，算法的实现已经非常的简单了(记得扫描二进制字符串的时候，是从左往右扫描)
 * 在此介绍一个模型，叫做确定有限状态机
 * 
 * 其被3进行模运算之后的余数有3种可能:
 * 0:表示余数为0
 * 1:表示余数为1
 * 2:表示余数为2
 * 
 * 每种可能看成一个节点，节点之间的有向边表示从一个状态转化为另一个状态，边上的数字表示了输入的情况
 * 则每次扫描都从一个状态转化为另外一个状态，则当扫描完成的时候，则最后所在的那个状态代表了结果(图略)
 * 
 * 
 */
public class ExtendsProblemAboutDFA
{
	public int beMode(String s)
	{
		if(s==null||s.length()==0)
			return 0;
		//用于去掉前置的0,index用于记录下第一个非0所在的字符串的下标
		int index=0;
		for(;index<s.length()&&s.charAt(index)=='0';index++);
		//当其字符串全部为0的时候，则其结果为0
		if(index==s.length())
			return 0;
		//由于其去掉了前置的0，所以，其状态会从1开始
		int result=1;
		for(;index<s.length();index++)
		{
			result=(result*2+(s.charAt(index)-'0'))%3;
		}
		return result;
	}
}
